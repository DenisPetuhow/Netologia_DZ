#include <iostream>
#include <Windows.h>

// Функция для обмена двух элементов массива
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

int pivoting(int* m__arr, int m_low, int m_hight) { // Функция для разделения массива на две части относительно опорного элемента
    int pivot = m__arr[m_hight]; // Выбираем последний элемент в качестве опорного
    int i = m_low - 1; // Индекс меньшего элемента

    for (int j = m_low; j < m_hight; j++) {
        // Если текущий элемент меньше или равен опорному
        if (m__arr[j] <= pivot) {
            i++; // Увеличиваем индекс меньшего элемента
            swap(m__arr[i], m__arr[j]); // Меняем местами элементы
        }
    }
    swap(m__arr[i + 1], m__arr[m_hight]); // Помещаем опорный элемент на правильную позицию
    return i + 1; // Возвращаем индекс опорного элемента
}


void quick_sort(int* m__arr, int m_low, int m_hight) {// Рекурсивная функция сортировкуи
    if (m_low < m_hight) {
        //Получаем индекс опорного элемента после разделения
        int pi = pivoting(m__arr, m_low, m_hight);
        //рекурсивно сортируем элементы до и после опорного елемента
        quick_sort(m__arr, m_low, pi - 1);
        quick_sort(m__arr, pi + 1, m_hight);
    }
}

//Функция обертка для вызова
void quick_sort(int* m_arr, int m_size) {
    quick_sort(m_arr, 0, m_size - 1);
}

// Функция для печати массива
void print_array(int* arr, int size) {
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

// Тестирование
int main() {

    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
    int arr[] = { 3, 43, 38, 29, 18, 72, 57, 61, 2, 33 };
    int size = sizeof(arr) / sizeof(arr[0]);

    std::cout << "Исходный массив: ";
    print_array(arr, size);

    quick_sort(arr, size);

    std::cout << "Отсортированный массив: ";
    print_array(arr, size);


    return 0;
}

//сначала мы выполняем функцию quick_sort, получаем значение срединного элемента pi( функция pivoting)
//в Функции pivoting берем последний элемент в виде опорного m_hight, после чего у нас идет сортировка массива, меняется последовательность изначального массива
// В результате получается массив до m_hight, которые меньше и после m_hight, которые больше, возрашаем опорный элемент ( и получает немного отсортированный массив)
// После снова вызываем quick_sort но уже с ограниченными элементами, при этом элемент с номером pi оставляем уже не изменном
//Если поудем по фукции до pi, то в результате снова получим число pi, которое будет на своем месте в общем массиве и от которога будет еще раз делится массив, и так далее
// В результате функция quick_sort вызывается пока не осанется один елемент с определенным индексом
// Сначала рекурсия идет по левому елементу от первого pi, потом как там все отсортирует идет в правую часть